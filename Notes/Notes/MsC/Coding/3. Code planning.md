<u>For Image2Count</u>
* Create model script for Image2Count to import
* Find out the shapes of $\textunderscore$embed.pt
To potentially learn how to use multiplex images, ie if each image is encoded separately.
* (DONE) Learn about how the subgraphs work
* (DONE) What are the maps for?
* Learn how the kfold is used

<u>For foundation model</u>
* Find out how multi-plex models output input work

<u>Other</u>
* csv generator
* Torch geometric
* Learn about QuPath
* ROI segment images based on GeoMx data
* Research LUNARC
* Test code locally

<u>GeoMx data</u>
I have .tiff files with circular ROIs and polygon shaped ROIs. I use the script to get labels for which ROI correspond to which ROI in the tabular count data.

There is also the problem of multiple ROIs but with different AOI, so I need to make a summarized count.

I use the cell segmentation extension in QuPath to make cell segmentations, and from there can get the cell positions into a csv

****

<u>Summarized ROIs script</u>
* Important columns:
SlideName
ROILabel
PatientID
ROIcoordinates

Counts should be summarized in a new column, so if AOI is looking at for example CD3, the AOI count for that should be added to that column

Each image in the .tiff file is an ROI (?)

So in essence:
* The tiff file has several ROIs
* I need to find which cells correspond to which ROIs
* I need to extract positions for the cells for those ROIs
* I need to form separate tiff files for each ROI
* I need to associate those cell positions with the new tiff files
* Each tiff file will have separate counts

Initial steps:
* Find where the ROI are in the tiff files (with the jupyter code?)
* Cut them out into their separate tiff files
* Extract the information from the xlsx of those ROIs
* Make count data for those ROIs
* Use the new tiff images to segment cells and get positions

<u>Questions</u>
* The tiff file is 4 in length, but there are several ROIs. Am I supposed to extract each ROI into separate .tiff files?


****

<u>Subgraphs</u>
line 180: Extracts the x and y coordinates of the outermost nodes, thus forming a box containing all the nodes

lines 182-183: Calculates the width and height of each box. The root square of subgraphs_per_graph is because the box is amount of subgraphs * amount of subgraphs (lets say k), so the total amount is k, so one side is square root of k wide.

lines 187-191: Forms a grid of points
line 193: enumerates each point
line 194: gets the index of the node that is closest to said point, does so by calculating the distance to every point, and picking the node with the smallest distance (weird equation though)

line 195: starting from node idx, collect all nodes in k_hop neighborhoods, and outputs edges, mapping, edge mask. Subset are the indexes of the original nodes included in the new subgraph, edge_index are edges to that subset, mapping is the index of the node idx relabeled in the subgraph, edge mask is a boolean mask which shows which edges of the original graph that are included. Relabeled nodes is set to true so subgraphs are reindexed.

line 200: A new graph is made, using the new attributes.

****

<u>Other notes for Image2Count</u>
* The model gets initialized to match input and output shape, so nothing will have to be changed here for foundation model to work
* Maps are used to keep track of IDs for each subgraph, so that we know which subgraphs are used for training or validation

What the hell
```
        IDs = np.array(df[~df.duplicated(subset=['ROI'], keep=False) | ~df.duplicated(subset=['ROI'], keep='first')].sort_values(by=['ROI'])['Patient_ID'].values)  #if duplicate, take first
```

So, creates a pandas dataframe, that takes NOT duplicates, meaning only unique ROIs, and if one is found, only keep it once (hence keep false), creates another dataframe that takes NOT duplicates of the first row of each unique ROI group, COMBINES these two arrays, sort them by ROI, and return their patient IDs.

So essentially, only extract IDs of non-duplicates of ROIs, sorted by ROIs (?)

And un_IDs returns then unique IDs, which gets the non-duplicate ROIs of unique IDs, meaning one unique ROI must correspond to a unique patient.

Why is this important?

* maps
First gets initialized as a list of total samples, which looks like indexes ranging from first sample to last sample, train map and val map have the same indexes for all samples. New maps get formed inside create_subgraphs.
line 216 which forms the new maps are basically:
The graphs are identified by their indexes, which in the grid forms for example:
1,2,3,4,5 (first 5 graphs, in the first row of the grid)
6,7,8,9,10 (the 5 graphs after, in the second row of the grid)
And each index in that grid, has subgraphs_per_graph ($k*k$) amount of graphs inside them
So, the grid width becomes essentially k wider.
The new index of a new subgraph then becomes:
$g*k$ , which is the box the subgraph resides in, and then +p the index inside that little box. In total: $g*k+p$

So the map is a new index array of the subgraphs, to keep track of which original graph it stems from.